---
title: "Replication Output for: Can the Government Deter Discrimination? Evidence from a Randomized Intervention in New York City"
author: "Albert H. Fang, Andrew M. Guess, and Macartan Humphreys"
date: "October 3, 2018"
output:
  html_document:
    keep_md: yes
    number_sections: yes
    theme: cosmo
    toc: yes
---



```{r, include=F}
  rm(list=ls(all=TRUE))
  require("knitr")
  opts_chunk$set(warning = F, comment = "", message = FALSE)
  options(knitr.kable.NA = '')
  run_appendix = TRUE
  run_lasso = TRUE
```



```{r, include=F}
  # Packages
  pkgs <- c("plyr","dplyr", "reshape2", "tidyr", "broom", "xtable",
    "weights","arm", "purrr", "glmnet", "animation", "maptools",
   "RColorBrewer", "AER", "Hmisc", "gtools","bootstrap","glmnet",
  "lme4", "nnet", "ggplot2", "stargazer", "stringr", "readr", "dataverse", "weights", "estimatr")

   # Install packages if not yet installed
  lapply(pkgs, function(x){
   if(x %in% rownames(installed.packages()) == FALSE) {install.packages(x, dependencies=TRUE, repos="https://cloud.r-project.org/")}
  })
  
  # Load packages
  library(plyr); library(dplyr); library(reshape2); library(tidyr); library(broom); library(xtable)
  library(weights); library(arm); library(purrr); library(glmnet); library(animation); library(maptools)
  library(RColorBrewer); library(AER); library(Hmisc); library(gtools); library(bootstrap); library(lme4)
  library(nnet); library(ggplot2); library(stargazer); library(stringr); library(readr); library(dataverse); library(estimatr)
```
[data]: https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/CF44OW
["_Can the Government Deter Discrimination? Evidence from a Randomized Intervention in New York City_"]: http://www.macartan.nyc/wp-content/uploads/2015/06/FGH_Paper.pdf
[This .Rmd file]: https://github.com/medinali/F-G-H_2018/blob/master/Replicate_Main.Rmd
[Replication code files]:https://github.com/medinali/F-G-H_2018

# Housekeeping


* [This .Rmd file]  produces the tables, figures, and analyses reported in the manuscript and in the (online) appendix from ["_Can the Government Deter Discrimination? Evidence from a Randomized Intervention in New York City_"]. This output file shows the core code and analyses used, as well as the main output from these analyses.
* We begin with a walk-through, through one set of results, step by step. We then introduce the automated analysis that replicates the core tables and figures reported in the paper.
* Analyses reported in the online appendix are produced optionally (the default setting is to produce these results).
* At various points in this Rmd file, we have set `echo=F` and `eval=F` in selected R code chunks to suppress displaying tex output in the Rmd output. To have these code chunks produce .tex table output files, set `eval=T`. 
* If you want to load [data] from Dataverse, in the second code chunk you must (1) set `local_data=FALSE` and (2) set your Dataverse API token in the line `Sys.setenv("DATAVERSE_KEY" = "ENTER-YOUR-API-TOKEN-HERE")`.
* [Replication code files] can be found online. 

```{r}
  # Set seed
  set.seed(20150229)

  # Load data locally or from dataverse
  # -- if TRUE: Data must be saved in the local root directory (specified in above code chunk)
  # -- if FALSE: Data will load from Dataverse; you must have a Dataverse API Token
  local_data <- TRUE
  if(!local_data){
    Sys.setenv("DATAVERSE_KEY" = "ENTER-YOUR-API-TOKEN-HERE")  ##### Put your Dataverse API Token here.
    Sys.setenv("DATAVERSE_SERVER" = "dataverse.harvard.edu")
  }
  source("code_0_read_data.R")

  # Load helper functions and prepare data
  source("code_1a_prep_data.R") 
  source("code_1b_helper_functions.R") 
```

# Manual walkthrough

We start by showing how to do a simple manual replication of core results. The remainder of this code does this same thing in a more automated way across various combinations.

## Treatment Levels

There are three treatment levels:

```{r}
table(dat$TA)
```

These correspond to 

0. control (c)
1. monitoring (m) and 
2. punitive (p). 

The key comparisons are thus:

* mc  (1 v 0)
* pc  (2 v 0)
* pm  (2 v 1)

For simplicity the code uses TA1 as a dummy for m, and TA2 as a dummy for p



## Racial groups

There are also three groups: Blacks (b), Hispanics (h), Whites (w). These yield three intergroup comparisons:

* wb (white - Black)
* wh (white - Hispanic)
* bh (Black - Hispanic)


## Outcomes

There are four outcomes that have been defined as between group differences (i.e., net discrimination measures). The stubs for these are:

```{r}
outvars <- c("nmeet_", "index.", "ncb_", "noff_")
```

Let's examine one set of outcome variables, the "ncb" (net discrimination in callbacks) variables:

```{r}
head(dplyr::select(dat, starts_with("ncb")))
table(dat$ncb_wh)
```

We see most of the time there is no difference betwen white and Hispanic testers on callbacks, but it is 50% more likely that white testers gets callbacks and Hispanic testers do not than vice versa.

## Parametric Analysis


The punitive-control comparison is done: 

```{r, results = "asis"}
manual_model <- lm(ncb_wh ~ TA2 + as.factor(block), data=filter(dat, TA %in% c(0,2)), weights = ipw20)
stargazer(manual_model,  omit = "block", type = "html")
```



This might be compared with:


1. The "non-parametric" analysis which uses blocked differences in means

```{r}
difference_in_means(ncb_wh ~ TA2, blocks = block, data=filter(dat, (block !=5) & (TA %in% c(0,2))))
```

Note that we exclude the block 5 for lack of units to calculate withn block variance:

```{r}
table(dat$TA2, dat$block)
```

2. A version of lm that uses robust standard errors

```{r}
lm_robust(ncb_wh ~ TA2, fixed_effects =  ~ block, data=filter(dat, TA %in% c(0,2)), weights = ipw20)
```



3. A raw cross tab (no weights)
```{r}
with(data=filter(dat, (block !=5) & (TA %in% c(0,2))), table(ncb_wh, TA2))
```

Note that the main differences between the parametric and non parametric approach is that the non parametric approach allows between block heterogeneity in average effects; in addition rather than using the assignment propensities it implictly uses information on the empirical shares in each condition in each block.



Note when examining different models that the following generally need to be adjusted:

* The outcome
* The treatment (TA2 here since we are interested in punitive)
* The data (to condition on the right comparisons, here `TA %in% c(0,2)`)
* The weights (here ipw20, since we are interested in comparing TA=2 and TA=0)

The core replication code automates these multiple adjustments, but any individual analysis can be checked manually, as above.

## Posteriors  

Posterior simulation using approach from Gelman and Hill (`arm` package):

```{r}
out_2 <- sim(manual_model, 3000)

hist(out_2@coef[,2], main = paste(
      "Effects of Punitive v Control on\nWhite v Hispanic Discrimination, 
       mean = ", round(mean(out_2@coef[,2]), 3),
      ", share neg =", round(mean(out_2@coef[,2] < 0), 3)
      ),
     xlim = c(-.2, .1))


```

 
# Tables and Figures in Main Text

## Parametric Results on Discrimination Levels and Treatment Effects: 

### Code for Analyses


```{r figure1analysis, echo=T, eval=T, warning=F}

# ---------------------------------------------------------------------- #
# DEFINE COLNAMES FOR OUTPUT TABLES

col.labels <- c("Outcome", "Estimate","SE","t","P")
# mc: monitoring - control
# pc: punitive - control
# pm: punitive - monitoring
# TA1: monitoring
# TA2: punitive

outvars <- c("nmeet_", "index.", "ncb_", "noff_")

reg_and_summ <- function(outvar, compare){
  
  depvar <- paste0(outvar, compare)
  model.mc <- paste(depvar," ~ TA1 + as.factor(block)",sep="")
  model.pc <- paste(depvar," ~ TA2 + as.factor(block)",sep="")
  model.pm <- paste(depvar," ~ TA2 + as.factor(block)",sep="")
 
  
  fit.mc <- lm(formula=model.mc, data=dat[dat$TA %in% c(0,1),], weights = ipw10)
  fit.pc <- lm(formula=model.pc, data=dat[dat$TA %in% c(0,2),], weights = ipw20)
  fit.pm <- lm(formula=model.pm, data=dat[dat$TA %in% c(1,2),], weights = ipw21)

  
  itt.mc <- summary(fit.mc)$coefficients[2,]
  itt.pc <- summary(fit.pc)$coefficients[2,]
  itt.pm <- summary(fit.pm)$coefficients[2,]
    
  if(compare == "wb" | compare == "wh"  ){
  itt.mc[4] <- pt(coef(summary(fit.mc))[,3], summary(fit.mc)$df[2], lower=TRUE)[2] #one sided p
  itt.pc[4] <- pt(coef(summary(fit.pc))[,3], summary(fit.pc)$df[2], lower=TRUE)[2] #one sided p
  } 
  
    list(mc     = itt.mc, pc     = itt.pc, pm     = itt.pm,
         fit.mc = fit.mc, fit.pc = fit.pc, fit.pm = fit.pm )
  
}

# Parametric Differences in Differences Results - White / Black Comparisons
itt.wb <- lapply(outvars, reg_and_summ,  compare = "wb" )
fit.wb.mc <- sapply(1:length(outvars), function(i) itt.wb[[i]]$fit.mc)
fit.wb.pc <- sapply(1:length(outvars), function(i) itt.wb[[i]]$fit.pc)
fit.wb.pm <- sapply(1:length(outvars), function(i) itt.wb[[i]]$fit.pm)

# Parametric Differences in Differences Results - White / Hispanic Comparisons
itt.wh <- lapply(outvars, reg_and_summ,  compare = "wh" )
fit.wh.mc <- sapply(1:length(outvars), function(i) itt.wh[[i]]$fit.mc)
fit.wh.pc <- sapply(1:length(outvars), function(i) itt.wh[[i]]$fit.pc)
fit.wh.pm <- sapply(1:length(outvars), function(i) itt.wh[[i]]$fit.pm)

# Parametric Differences in Differences Results - Black / Hispanic Comparisons
itt.bh <- lapply(outvars, reg_and_summ,  compare = "bh" )
fit.bh.mc <- sapply(1:length(outvars), function(i) itt.bh[[i]]$fit.mc)
fit.bh.pc <- sapply(1:length(outvars), function(i) itt.bh[[i]]$fit.pc)
fit.bh.pm <- sapply(1:length(outvars), function(i) itt.bh[[i]]$fit.pm)



```

### Simple print out of parametric results

```{r, results = "asis", warning=F}
# WB MC
stargazer(fit.wb.mc[[1]], fit.wb.mc[[2]], fit.wb.mc[[3]], fit.wb.mc[[4]], 
          omit = "block", type = "html", 
          p = lapply(fit.wb.mc, function(fit)   
            pt(coef(summary(fit))[,3], summary(fit)$df[2], lower=TRUE) ))

# WB PC
stargazer(fit.wb.pc[[1]], fit.wb.pc[[2]], fit.wb.pc[[3]], fit.wb.pc[[4]], 
          omit = "block", type = "html" )

# WB PM
stargazer(fit.wb.pm[[1]], fit.wb.pm[[2]], fit.wb.pm[[3]], fit.wb.pm[[4]], 
          omit = "block", type = "html",
          p = lapply(fit.wb.pm, function(fit) 
            pt(coef(summary(fit))[,3], summary(fit)$df[2], lower=TRUE) ))

# WH MC
stargazer(fit.wh.mc[[1]], fit.wh.mc[[2]], fit.wh.mc[[3]], fit.wh.mc[[4]],
          omit = "block", type = "html",
          p = lapply(fit.wh.mc, function(fit) 
            pt(coef(summary(fit))[,3], summary(fit)$df[2], lower=TRUE) ) )

# WH PC
stargazer(fit.wh.pc[[1]], fit.wh.pc[[2]], fit.wh.pc[[3]], fit.wh.pc[[4]], 
          omit = "block", type = "html",
          p = lapply(fit.wh.pc, function(fit) 
            pt(coef(summary(fit))[,3], summary(fit)$df[2], lower=TRUE) ))
# WH PM
stargazer(fit.wh.pm[[1]], fit.wh.pm[[2]], fit.wh.pm[[3]], fit.wh.pm[[4]], 
          omit = "block", type = "html")

# BH MC
stargazer(fit.bh.mc[[1]], fit.bh.mc[[2]], fit.bh.mc[[3]], fit.bh.mc[[4]], 
          omit = "block", type = "html")

# BH PC
stargazer(fit.bh.pc[[1]], fit.bh.pc[[2]], fit.bh.pc[[3]], fit.bh.pc[[4]],
          omit = "block", type = "html")

# BH PM
stargazer(fit.bh.pm[[1]], fit.bh.pm[[2]], fit.bh.pm[[3]], fit.bh.pm[[4]],
          omit = "block", type = "html")

```

### Storing parametric results

```{r}
# Parametric Differences in Differences Results -White / Black Comparisons
itt.wb.mc <- sapply(1:length(outvars), function(i) itt.wb[[i]]$mc)
itt.wb.pc <- sapply(1:length(outvars), function(i) itt.wb[[i]]$pc)
itt.wb.pm <- sapply(1:length(outvars), function(i) itt.wb[[i]]$pm)

# Parametric Differences in Differences Results - White / Hispanic Comparisons
itt.wh.mc <- sapply(1:length(outvars), function(i) itt.wh[[i]]$mc)
itt.wh.pc <- sapply(1:length(outvars), function(i) itt.wh[[i]]$pc)
itt.wh.pm <- sapply(1:length(outvars), function(i) itt.wh[[i]]$pm)

# Parametric Differences in Differences Results - Black / Hispanic Comparisons
itt.bh.mc <- sapply(1:length(outvars), function(i) itt.bh[[i]]$mc)
itt.bh.pc <- sapply(1:length(outvars), function(i) itt.bh[[i]]$pc)
itt.bh.pm <- sapply(1:length(outvars), function(i) itt.bh[[i]]$pm)


#----- CIs -----#
df.w_ <- sapply(list(df.wb.mc = fit.wb.mc, 
                     df.wb.pc = fit.wb.pc, 
                     df.wb.pm = fit.wb.pm,
                     df.wh.mc = fit.wh.mc,
                     df.wh.pc = fit.wh.pc, 
                     df.wh.pm = fit.wh.pm,
                     df.bh.mc = fit.bh.mc,
                     df.bh.pc = fit.bh.pc,
                     df.bh.pm = fit.bh.pm),
                function(fit){
                        unlist(lapply(fit, function(x) summary(x)$df[2]))[2:4]})

df.2g.10 <-  c(df.w_[,c("df.wb.mc", "df.wh.mc", "df.bh.mc")])
df.2g.20 <-  c(df.w_[,c("df.wb.pc", "df.wh.pc", "df.bh.pc")])
df.2g.21 <-  c(df.w_[,c("df.wb.pm", "df.wh.pm", "df.bh.pm")])

cv.2g.10 <- qt(p=0.025, df=df.2g.10, lower.tail=TRUE)
cv.2g.20 <- qt(p=0.025, df=df.2g.20, lower.tail=TRUE)
cv.2g.21 <- qt(p=0.025, df=df.2g.21, lower.tail=TRUE)

cv.2g <- c(cv.2g.10, cv.2g.20, cv.2g.21)


```

```{r, include=FALSE}

# Add outcome measure labels
itt.wb.mc <- cbind(outvars.wb.labs, t(itt.wb.mc))
itt.wb.pc <- cbind(outvars.wb.labs, t(itt.wb.pc))
itt.wb.pm <- cbind(outvars.wb.labs, t(itt.wb.pm))

itt.wh.mc <- cbind(outvars.wh.labs, t(itt.wh.mc))
itt.wh.pc <- cbind(outvars.wh.labs, t(itt.wh.pc))
itt.wh.pm <- cbind(outvars.wh.labs, t(itt.wh.pm))

itt.bh.mc <- cbind(outvars.bh.labs, t(itt.bh.mc))
itt.bh.pc <- cbind(outvars.bh.labs, t(itt.bh.pc))
itt.bh.pm <- cbind(outvars.bh.labs, t(itt.bh.pm))

# Add column names
colnames(itt.wb.mc) <- colnames(itt.wb.pc) <- colnames(itt.wb.pm) <- col.labels
colnames(itt.wh.mc) <- colnames(itt.wh.pc) <- colnames(itt.wh.pm) <- col.labels
colnames(itt.bh.mc) <- colnames(itt.bh.pc) <- colnames(itt.bh.pm) <- col.labels

```




```{r, include = TRUE}

# Stack output 
out2 <- rbind(itt.wb.mc, itt.wh.mc, itt.bh.mc,
              itt.wb.pc, itt.wh.pc, itt.bh.pc,
              itt.wb.pm, itt.wh.pm, itt.bh.pm)

out2 <- out2[-seq(1,33,4),]


# Round and format results
for(i in 2:ncol(out2)) out2[,i] <- round(as.numeric(out2[,i]),3)
 out2[,"P"] <- paste("(", out2[,"P"],")",sep="")

itt.2g.ci <- as.numeric(out2[,2]) +
  abs(cv.2g)*cbind(lower.ci = -as.numeric(out2[,3]), upper.ci = as.numeric(out2[,3])) 

itt.est <- cbind(out2, itt.2g.ci)
```

```{r, include = FALSE}
itt.est[, -1] <- apply(itt.est[, -1], 2, function(x) round(as.numeric(x),3))

# Assemble results
itt.2g.tab <- cbind(out2, cbind(apply(itt.2g.ci, 1, function(x) paste("[", round(x[1],3) ,", ", round(x[2],3), "]", sep=""))))
colnames(itt.2g.tab) <- c("Outcome", "Estimate", "SE", "t", "p-value", "95% CI")
# Save results
write.csv(itt.2g.tab, "out_tablea7_itt_2g_blockfe_nocovs_UNFORMATTED.csv", row.names=FALSE)


#itt.est <- read.csv("out_tablea7_itt_2g_blockfe_nocovs_UNFORMATTED.csv", header=TRUE, stringsAsFactors=FALSE)

#itt.est$lower.ci <- as.numeric(sapply(strsplit(itt.est[,6], ", "), function(x) gsub("[", "", x[1], fixed=TRUE)))
#itt.est$upper.ci <- as.numeric(sapply(strsplit(itt.est[,6], ", "), function(x) gsub("]", "", x[2], fixed=TRUE)))

row_labels <- c("W-B", "W-H", "B-H")
col_labels <- c("M-C", "P-C", "P-M")

```


```{r prep_figure1plot, eval=T, echo=T, warning=F}

outlist <-
  lapply(c(cb.reg = "callback" ,
          off.reg = "offer",
          meindex.reg = "Index"),  
         function(keyword){
             # Grab relevant outcome row 
            itt <-  itt.est[grepl(keyword, itt.est[,1], fixed=TRUE),]
            with(as.data.frame(itt),
              list(coef=matrix(Estimate, nrow=3, ncol=3, byrow=FALSE),
              se=matrix(SE, nrow=3, ncol=3, byrow=FALSE),
              lower=matrix(lower.ci, nrow=3, ncol=3, byrow=FALSE),
              upper=matrix(upper.ci, nrow=3, ncol=3, byrow=FALSE))) })
       
cb.reg      <-   outlist$cb.reg 
off.reg     <-   outlist$off.reg 
meindex.reg <-   outlist$meindex.reg 

```


```{r, include= FALSE}
cb.reg      <-  lapply(cb.reg,      function(x) apply(x, 2, as.numeric))
off.reg     <-  lapply(off.reg,     function(x) apply(x, 2, as.numeric))
meindex.reg <-  lapply(meindex.reg, function(x) apply(x, 2, as.numeric))

```


## Nonparametric and other Figure 1 Estimates

### Prep

```{r non_param, eval=T, echo=T, warning=F}
# Create and rename variables
dat$cb_w <- dat$cb_C
dat$cb_h <- dat$cb_B
dat$cb_b <- dat$cb_A

dat$off_w <- dat$off_C
dat$off_h <- dat$off_B
dat$off_b <- dat$off_A

dat$meindex_w <- dat$meindex.impute_C 
dat$meindex_h <- dat$meindex.impute_B
dat$meindex_b <- dat$meindex.impute_A 

dat$meindex_wb <- dat$meindex.impute_C - dat$meindex.impute_A
dat$meindex_wh <- dat$meindex.impute_C - dat$meindex.impute_A
dat$meindex_bh <- dat$meindex.impute_A - dat$meindex.impute_B
```

### Quadrant 1,1

```{r}
# quad[1,1] --------------------------------------------
 # Function to create each single row in data.frame
f_11 <- function(Y, TA = dat$TA, W = dat$ipw, a) {
  N <- sum(TA==a)
  out <- data.frame(estimate =  weighted.mean(Y[TA==a], W[TA==a]))
  out$std.error <- sqrt(wtd.var(Y[TA==a], W[TA==a])/N)
  out$df <- N - 1
  error <-  abs(qt(p=.025, df= out$df, lower.tail=TRUE))
  out$conf.low  <- out$estimate - error*out$std.error
  out$conf.high <- out$estimate + error*out$std.error
  out
}
 # function to call f_a11() for each level
quad_11 <- function(Y){
     outcomes <- paste0(Y, c("_w",  "_b", "_h"))
     Ys <- dat[, outcomes]
    rbind(
      w_c = f_11(Ys[,1], a = 0),
      b_c = f_11(Ys[,2], a = 0),
      h_c = f_11(Ys[,3], a = 0),
      w_m = f_11(Ys[,1], a = 1),
      b_m = f_11(Ys[,2], a = 1),
      h_m = f_11(Ys[,3], a = 1),
      w_p = f_11(Ys[,1], a = 2),
      b_p = f_11(Ys[,2], a = 2),
      h_p = f_11(Ys[,3], a = 2))
    }

```

### Quadrant 1,2

```{r}

# quad[1,2] --------------------------------------------
f_12 <- function(Y, a, b, TA = dat$TA, W = dat$ipw) {
  X <- (TA==a)[TA==a | TA==b]
  lm12 <- lm(Y[TA==a | TA==b]  ~ X, weight = W[TA==a | TA==b])
  summ <- summary(lm12)
  out <- tidy(summ) 
  out$df <- summ$df[2]
  error <-  abs(qt(p=.025, df= out$df, lower.tail=TRUE)) 
  out$conf.low  <- out$estimate - error*out$std.error
  out$conf.high <- out$estimate + error*out$std.error
  as.data.frame(out[out$term == "XTRUE", ] )
}
  
 # function to call f_a11() for each level
quad_12 <- function(Y){
     outcomes <- paste0(Y, c("_w",  "_b", "_h"))
     Ys <- dat[, outcomes]
    rbind(
      w_mc = f_12(Ys[,1], a = 1, b = 0),
      b_mc = f_12(Ys[,2], a = 1, b = 0),
      h_mc = f_12(Ys[,3], a = 1, b = 0),
      w_pc = f_12(Ys[,1], a = 2, b = 0),
      b_pc = f_12(Ys[,2], a = 2, b = 0),
      h_pc = f_12(Ys[,3], a = 2, b = 0),
      w_pm = f_12(Ys[,1], a = 2, b = 1),
      b_pm = f_12(Ys[,2], a = 2, b = 1),
      h_pm = f_12(Ys[,3], a = 2, b = 1))
    }

```

### Quadrant 2,1

```{r}

# quad[2,1] --------------------------------------------
f_21 <- function(Y1, Y2, a,  TA = dat$TA, W = dat$ipw) {
  out <- data.frame(estimate =  weighted.mean((Y1-Y2)[TA==a], W[TA==a]))
  ttest <- wtd.t.test((Y1-Y2)[TA==a], weight=W[TA==a])
  out$std.error <- ttest$additional[4]
  out$p  <- ttest$coefficient[3]
  out$df <- ttest$coefficient[2]
  error <-  abs(qt(p=.025, df= out$df, lower.tail=TRUE))
  out$conf.low  <- out$estimate - error*out$std.error
  out$conf.high <- out$estimate + error*out$std.error
  as.data.frame(out)
}

quad_21 <- function(Y){
     outcomes <- paste0(Y, c("_w",  "_b", "_h"))
     Ys <- dat[, outcomes]
    rbind(
      wb_c = f_21(Ys[,1], Ys[,2],  a = 0),
      wh_c = f_21(Ys[,1], Ys[,3],  a = 0),
      bh_c = f_21(Ys[,2], Ys[,3],  a = 0),
      wb_m = f_21(Ys[,1], Ys[,2],  a = 1),
      wh_m = f_21(Ys[,1], Ys[,3],  a = 1),
      bh_m = f_21(Ys[,2], Ys[,3],  a = 1),
      wb_p = f_21(Ys[,1], Ys[,2],  a = 2),
      wh_p = f_21(Ys[,1], Ys[,3],  a = 2),
      bh_p = f_21(Ys[,2], Ys[,3],  a = 2))
    }
```

### Quadrant 2,2

```{r}
# quad[2,2] --------------------------------------------
 # Non parametric Differences in Differences Results
# It excludes block 5 which has too little variance to estimate a variance term.
f_22 <- function(Y, TA = "TA",  C1, C2, exclude, data = dat){
  dim22 <- difference_in_means(formula(paste(Y,  "~" ,TA)), 
                           blocks = block, 
                           data=filter(data, block !=5), 
                           condition1 = C1,
                           condition2 = C2,
                           subset = TA!= exclude)
  tidy(dim22)
}

quad_22 <- function(Y){
    Ys <- paste0(Y, c("_wb",  "_wh", "_bh"))
    rbind(
      wb_mc = f_22(Ys[1], C1 = 0, C2= 1, exclude = 2),
      wh_mc = f_22(Ys[2], C1 = 0, C2= 1, exclude = 2),
      bh_mc = f_22(Ys[3], C1 = 0, C2= 1, exclude = 2),
      wb_pc = f_22(Ys[1], C1 = 0, C2= 2, exclude = 1), 
      wh_pc = f_22(Ys[2], C1 = 0, C2= 2, exclude = 1),
      bh_pc = f_22(Ys[3], C1 = 0, C2= 2, exclude = 1),
      wb_pm = f_22(Ys[1], C1 = 1, C2= 2, exclude = 0),
      wh_pm = f_22(Ys[2], C1 = 1, C2= 2, exclude = 0),
      bh_pm = f_22(Ys[3], C1 = 1, C2= 2, exclude = 0))
    }

# Produce tables
cb_11  <- quad_11("cb")
cb_12  <- quad_12("cb")
cb_21  <- quad_21("cb")
cb_22  <- quad_22("ncb")
off_11 <- quad_11("off")  
off_12 <- quad_12("off")   
off_21 <- quad_21("off") 
off_22  <- quad_22("noff")
off_11 <- quad_11("off")  
off_12 <- quad_12("off")   
off_21 <- quad_21("off") 
off_22  <- quad_22("noff")
index_11 <- quad_11("meindex")  
index_12 <- quad_12("meindex")   
index_21 <- quad_21("meindex" ) 
index_22  <- quad_22("meindex")

  
```

## Produce Figure 1

```{r, include=FALSE}

# FIGURE SPECS
col_width <- 7
row_height <- 4
width_spec <- c(4, 4, rep(col_width, 3), 2, rep(col_width, 3))
height_spec <- c(2, 2, row_height, 2, row_height)
colhead.cex <- 2.7 # font size for column headings
colhead2.cex <- 2.7 # font size for treatment headings
rowsub.cex <- 3  # font size for variable labels
col_headings <- c("Control", "Monitoring", "Punitive", "Monitoring\nvs. Control", "Punitive\nvs. Control", "Punitive vs.\nMonitoring")
pdf_width <- 24
pdf_height <- 11
layout_vec <- c(0,	0, 23,	23,	23,	0,	24,	24,	24,
                0, 0, 17, 18, 19, 14, 20, 21, 22,
                25, 15, 1, 2, 3, 14, 4, 5, 6,
                0, 13, 13, 13, 13, 13, 13, 13, 13,
                26, 16, 7, 8, 9, 14, 10, 11, 12)
png_width <- 2400
png_height <- 1100
```

```{r figure1plot, echo=TRUE, message=FALSE, warning=F}

# HELPER FUNCTIONS

#================#
# Plot function used in Figure 1
#================#

# Take matrices CB, OFF, MEINDEX
# Take matrices CB.REG, OFF.REG, MEINDEX.REG

# plot with a single set of three or two threes
plot.helper <- function(coefs1=1:3, sds1=3:5, lower1, upper1, coefs2=NA, sds2=NA, lower2, upper2, double=FALSE, xlim=NULL ){
  coefplot(coefs1, sds1, CI=2, lower.conf.bounds=lower1, upper.conf.bounds=upper1, pch.pts=21, varnames="", main = "", h.axis = FALSE, xlim = xlim, cex.pts=3, lwd=3)
  if(double) coefplot(coefs2, sds2, CI=2, lower.conf.bounds=lower2, upper.conf.bounds=upper2, add=TRUE, pch.pts=19, cex.pts=3, lwd=3)
  axis(side=1, line=2, cex.axis=1.5, padj=1)
}


itt.plot <- function(y11,y12, y21, y22_np, y_22_p, xlim){
  # Raw means ci
  # upper left quadrant
  for(i in 1:3) {
    trt = list(control    = c("w_c",  "b_c","h_c"),    #  i = 1 
               monitoring = c("w_m", "b_m", "h_m"), # i = 2
               punitive   = c("w_p", "b_p", "h_p"))   # i = 3
  
    plot.helper(coefs1 = rev(y11[trt[[i]], "estimate" ]),
                sds1   = rev(y11[trt[[i]], "std.error"]),
                lower1 = rev(y11[trt[[i]], "conf.low" ]), 
                upper1 = rev(y11[trt[[i]], "conf.high"]),
                xlim   = xlim[[1]])}

  # D-I-M between treatments conditional on each group - upper right quadrant
    for(i in 1:3) {
    trt = list(mc    = c("w_mc", "b_mc","h_mc"),  #  i = 1 
               pc = c("w_pc", "b_pc", "h_pc"), # i = 2
               pm   = c("w_pm", "b_pm", "h_pm")) # i = 3
  
    plot.helper(coefs1 = rev(y12[trt[[i]], "estimate" ]),
                sds1   = rev(y12[trt[[i]], "std.error"]),
                lower1 = rev(y12[trt[[i]], "conf.low" ]), 
                upper1 = rev(y12[trt[[i]], "conf.high"]),
                xlim   = xlim[[2]])}
    

     for(i in 1:3) {
    trt = list(c = c("wb_c", "wh_c", "bh_c"),  #  i = 1 
               m = c("wb_m", "wh_m", "bh_m"), # i = 2
               p = c("wb_p", "wh_p", "bh_p")) # i = 3
  
    plot.helper(coefs1 = rev(y21[trt[[i]], "estimate" ]),
                sds1   = rev(y21[trt[[i]], "std.error"]),
                lower1 = rev(y21[trt[[i]], "conf.low" ]), 
                upper1 = rev(y21[trt[[i]], "conf.high"]),
                xlim   = xlim[[3]])
    
        if ( i == 1 ) {  # highlight control group
      abline(h=3, col=rgb(0,0,0,.1), lwd=40)
      abline(h=2, col=rgb(0,0,0,.1), lwd=40)}}
   # D-I-M between groups conditional on treatment assigment - lower left quadrant

    
  # lower right quadrant
    for(i in 1:3) {
     trt = list(c = c("wb_mc", "wh_mc","bh_mc"),  #  i = 1 
                m = c("wb_pc", "wh_pc", "bh_pc"), # i = 2
                p = c("wb_pm", "wh_pm", "bh_pm")) # i = 3
    plot.helper(coefs1 = rev(y22_np[trt[[i]], "estimate" ]),
                sds1   = rev(y22_np[trt[[i]], "std.error"]),
                lower1 = rev(y22_np[trt[[i]], "conf.low" ]), 
                upper1 = rev(y22_np[trt[[i]], "conf.high"]),
                coefs2=rev(y_22_p$coef[1:3,(i )]), 
                sds2=rev(y_22_p$se[1:3,(i)]), 
                lower2=rev(y_22_p$lower[1:3,(i)]), 
                upper2=rev(y_22_p$upper[1:3,(i)]),
                double=TRUE, xlim=xlim[[4]])
    if ( i == 5 ){  # highlight P-C
      abline(h=3, col=rgb(0,0,0,.1), lwd=40)
      abline(h=2, col=rgb(0,0,0,.1), lwd=40)  }}
    
}

## MAKE PDF FIGURES FOR PAPER AND PNG FIGURES FOR RMD FILE

## CALLBACKS
# Make PNG version for Rmd output
png("out_figure1a_6x6_cb.png", width=png_width, height=png_height)
par(oma=c(5,0,0,0), mar=c(5,0,0,0))
layout(matrix(layout_vec, nrow=5, ncol=9, byrow=TRUE), widths=width_spec, heights=height_spec)
# plots
xlims <- list(c(0, .25), c(-.15, .15), c(-.15, .15), c(-.2, .2))
itt.plot(y11 = cb_11, y12 = cb_12, y21 = cb_21, y22_np  = cb_22, y_22_p = cb.reg, xlims)
# dividers
frame(); abline(h=.5, lwd=2)
frame(); abline(v=.5, lwd=2)
# row labels
frame(); text(.6, .85, "White", cex=rowsub.cex); text(.6, .5, "Black", cex=rowsub.cex); text(.6, .15, "Hisp.", cex=rowsub.cex)
frame(); text(.6, .85, "W-B", cex=rowsub.cex); text(.6, .5, "W-H", cex=rowsub.cex); text(.6, .15, "B-H", cex=rowsub.cex)
# col labels
for(i in 1:6) {
  frame(); text(.5, .5, col_headings[i], cex=colhead.cex)
}
# meta col labels
frame(); text(.5, .5, "Treatment Group Means", cex=colhead.cex)
frame(); text(.5, .5, "Differences between Treatment Groups", cex=colhead.cex)
# meta row labels
frame(); text(.5, .5, "Tester Race\nGroup Means", cex=colhead.cex, srt=90)
frame(); text(.5, .5, "Intergroup\nDifferences", cex=colhead.cex, srt=90)
dev.off()

## OFFERS
# Make PNG version for Rmd output
png("out_figure1b_6x6_off.png", width=png_width, height=png_height)
par(oma=c(5,0,0,0), mar=c(5,0,0,0))
layout(matrix(layout_vec, nrow=5, ncol=9, byrow=TRUE), widths=width_spec, heights=height_spec)
# plots
xlims <- list(c(0, .15), c(-.1, .1), c(-.1, .1), c(-.2, .2))
itt.plot(y11 = off_11, y12 = off_12, y21 = off_21, y22_np  = off_22, y_22_p = off.reg, xlims)
# dividers
frame(); abline(h=.5, lwd=2)
frame(); abline(v=.5, lwd=2)
# row labels
frame(); text(.6, .85, "White", cex=rowsub.cex); text(.6, .5, "Black", cex=rowsub.cex); text(.6, .15, "Hisp.", cex=rowsub.cex)
frame(); text(.6, .85, "W-B", cex=rowsub.cex); text(.6, .5, "W-H", cex=rowsub.cex); text(.6, .15, "B-H", cex=rowsub.cex)
# col labels
for(i in 1:6) {
  frame(); text(.5, .5, col_headings[i], cex=colhead.cex)
}
# meta col labels
frame(); text(.5, .5, "Treatment Group Means", cex=colhead.cex)
frame(); text(.5, .5, "Differences between Treatment Groups", cex=colhead.cex)
# meta row labels
frame(); text(.5, .5, "Tester Race\nGroup Means", cex=colhead.cex, srt=90)
frame(); text(.5, .5, "Intergroup\nDifferences", cex=colhead.cex, srt=90)
dev.off()

## INDEX

# Make PNG version for Rmd output
png("out_figurea3_6x6_index.png", width=2400, height=1100)
par(oma=c(5,0,0,0), mar=c(5,0,0,0))
layout(matrix(layout_vec, nrow=5, ncol=9, byrow=TRUE), widths=width_spec, heights=height_spec)
# plots
xlims <- list(c(-.3, .3), c(-.35, .35), c(-.35, .35), c(-.35, .35))
itt.plot(y11 = index_11, y12 = index_12, y21 = index_21, y22_np  = index_22, 
         y_22_p =meindex.reg, xlims)
# dividers
frame(); abline(h=.5, lwd=2)
frame(); abline(v=.5, lwd=2)
# row labels
frame(); text(.6, .85, "White", cex=rowsub.cex); text(.6, .5, "Black", cex=rowsub.cex); text(.6, .15, "Hisp.", cex=rowsub.cex)
frame(); text(.6, .85, "W-B", cex=rowsub.cex); text(.6, .5, "W-H", cex=rowsub.cex); text(.6, .15, "B-H", cex=rowsub.cex)
# col labels
for(i in 1:6) {
  frame(); text(.5, .5, col_headings[i], cex=colhead.cex)
}
# meta col labels
frame(); text(.5, .5, "Treatment Group Means", cex=colhead.cex)
frame(); text(.5, .5, "Differences between Treatment Groups", cex=colhead.cex)
# meta row labels
frame(); text(.5, .5, "Tester Race\nGroup Means", cex=colhead.cex, srt=90)
frame(); text(.5, .5, "Intergroup\nDifferences", cex=colhead.cex, srt=90)
dev.off()

```


```{r, include = FALSE, message=FALSE}
## MAKE PDF FIGURES FOR PAPER AND PNG FIGURES FOR RMD FILE

## CALLBACKS
pdf("out_figure1a_6x6_cb.pdf", width=pdf_width, height=pdf_height)
  par(oma=c(5,0,0,0), mar=c(5,0,0,0))
  layout(matrix(layout_vec, nrow=5, ncol=9, byrow=TRUE), widths=width_spec, heights=height_spec)
  # plots
  xlims <- list(c(0, .25), c(-.15, .15), c(-.15, .15), c(-.2, .2))
  itt.plot(y11 = cb_11, y12 = cb_12, y21 = cb_21, y22_np  = cb_22, y_22_p = cb.reg, xlims)
  # dividers
  frame(); abline(h=.5, lwd=2)
  frame(); abline(v=.5, lwd=2)
  # row labels
  frame(); text(.6, .85, "White", cex=rowsub.cex); text(.6, .5, "Black", cex=rowsub.cex); text(.6, .15, "Hisp.", cex=rowsub.cex)
  frame(); text(.6, .85, "W-B", cex=rowsub.cex); text(.6, .5, "W-H", cex=rowsub.cex); text(.6, .15, "B-H", cex=rowsub.cex)
  # col labels
  for(i in 1:6) {
    frame(); text(.5, .5, col_headings[i], cex=colhead.cex)
  }
  # meta col labels
  frame(); text(.5, .5, "Treatment Group Means", cex=colhead.cex)
  frame(); text(.5, .5, "Differences between Treatment Groups", cex=colhead.cex)
  # meta row labels
  frame(); text(.5, .5, "Tester Race\nGroup Means", cex=colhead.cex, srt=90)
  frame(); text(.5, .5, "Intergroup\nDifferences", cex=colhead.cex, srt=90)
dev.off()

## OFFERS
pdf("out_figure1b_6x6_off.pdf", width=pdf_width, height=pdf_height)
  par(oma=c(5,0,0,0), mar=c(5,0,0,0))
  layout(matrix(layout_vec, nrow=5, ncol=9, byrow=TRUE), widths=width_spec, heights=height_spec)
  # plots
  xlims <- list(c(0, .15), c(-.1, .1), c(-.1, .1), c(-.2, .2))
  itt.plot(y11 = off_11, y12 = off_12, y21 = off_21, y22_np  = off_22, y_22_p = off.reg, xlims)
  # dividers
  frame(); abline(h=.5, lwd=2)
  frame(); abline(v=.5, lwd=2)
  # row labels
  frame(); text(.6, .85, "White", cex=rowsub.cex); text(.6, .5, "Black", cex=rowsub.cex); text(.6, .15, "Hisp.", cex=rowsub.cex)
  frame(); text(.6, .85, "W-B", cex=rowsub.cex); text(.6, .5, "W-H", cex=rowsub.cex); text(.6, .15, "B-H", cex=rowsub.cex)
  # col labels
  for(i in 1:6) {
    frame(); text(.5, .5, col_headings[i], cex=colhead.cex)
  }
  # meta col labels
  frame(); text(.5, .5, "Treatment Group Means", cex=colhead.cex)
  frame(); text(.5, .5, "Differences between Treatment Groups", cex=colhead.cex)
  # meta row labels
  frame(); text(.5, .5, "Tester Race\nGroup Means", cex=colhead.cex, srt=90)
  frame(); text(.5, .5, "Intergroup\nDifferences", cex=colhead.cex, srt=90)
dev.off()

## INDEX
pdf("out_figurea3_6x6_index.pdf", width=pdf_width, height=pdf_height)
  par(oma=c(5,0,0,0), mar=c(5,0,0,0))
  layout(matrix(layout_vec, nrow=5, ncol=9, byrow=TRUE), widths=width_spec, heights=height_spec)
  # plots
  xlims <- list(c(-.3, .3), c(-.35, .35), c(-.35, .35), c(-.35, .35))
  itt.plot(y11 = index_11, y12 = index_12, y21 = index_21, y22_np  = index_22, 
           y_22_p =meindex.reg, xlims)
  # dividers
  frame(); abline(h=.5, lwd=2)
  frame(); abline(v=.5, lwd=2)
  # row labels
  frame(); text(.6, .85, "White", cex=rowsub.cex); text(.6, .5, "Black", cex=rowsub.cex); text(.6, .15, "Hisp.", cex=rowsub.cex);
  frame(); text(.6, .85, "W-B", cex=rowsub.cex); text(.6, .5, "W-H", cex=rowsub.cex); text(.6, .15, "B-H", cex=rowsub.cex)
  # col labels
  for(i in 1:6) {
    frame(); text(.5, .5, col_headings[i], cex=colhead.cex)
  }
  # meta col labels
  frame(); text(.5, .5, "Treatment Group Means", cex=colhead.cex)
  frame(); text(.5, .5, "Differences between Treatment Groups", cex=colhead.cex)
  # meta row labels
  frame(); text(.5, .5, "Tester Race\nGroup Means", cex=colhead.cex, srt=90)
  frame(); text(.5, .5, "Intergroup\nDifferences", cex=colhead.cex, srt=90)
dev.off()

```

![**Figure 1, Panel A: Outcome 1: Net Discrimination in Receiving Callbacks**](out_figure1a_6x6_cb.png)

![**Figure 1, Panel B: Outcome 2: Net Discrimination in Receiving Offers**](out_figure1b_6x6_off.png)

## Figure 2: Posterior Densities of Treatment Effects on Discrimination

```{r figure2, echo=T, eval=T, warning=F, message=FALSE}
##=============================================================================##
## Figure 2: Posterior Probabilities
##=============================================================================##

#### ======== FUNCTIONS =========== ####

## function to compute the bayesian analog of the lmfit
## using non-informative priors and Monte Carlo scheme
## based on N samples;
#  see http://www.r-bloggers.com/bayesian-linear-regression-analysis-without-tears-r/

bayes.graph <- function(depvar, treat, weight, block = NULL, main = "Callbacks", #comparison = "Hispanic", 
                       trt_text = "Punitive", draws = 10000, xloc = 0.15, yloc = 13, textadj = 1, ylab = "", print_title = FALSE,
                       vertical = TRUE, maxline = FALSE, addlegend = FALSE, addbox = TRUE, ylim = c(0,18)) {

  lmfit <- lm(depvar ~ treat + factor(block), weights = weight)
  
  bf <- data.frame(arm::sim(lmfit, draws)@coef)
  post_punitive <- bf$treat

  # graph
  dens <- density(post_punitive, bw = 0.01, from = -.17, to = .10) # to = .04 ; bw = 0.005

  left <- quantile(post_punitive, 0)
  x1 <- min(which(dens$x >= left))
  x2 <- max(which(dens$x <  0))

  pct_left <- round((diff(dens$x[1:2])*sum(dens$y[1:x2])) / (diff(dens$x[1:2])*sum(dens$y)), digits = 3) * 100 # % MOC < 0

  main_txt <- ""
  if(print_title) { main_txt <- paste0("Outcome: ", main, "\n(", trt_text, " vs. Control)") }
  plot(dens, xlab = "", ylab = ylab, main = main_txt, bty = "n", lwd = 2, xlim = c(-.15, .15), ylim = ylim, cex.main = 1.5, cex.lab = 1.2, cex.axis = 1, font = 1) #xlim = c(-.17, .10), ylim = c(0,17)
  with(dens, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col="gray"))
  if(maxline) abline(v = mean(post_punitive), col = "red", lty = 2, lwd = 3)
  text(x = xloc, y = yloc, paste0(pct_left, "%"), adj = c(textadj, NA), cex = 1.2)
  text(x = xloc, y = yloc-.8, "less than zero", adj = c(textadj, NA), cex = 1.2)
  if(vertical) abline(v=0)
  if(addbox) box()
}


#### ======== ANALYSES AND GRAPH RESULTS =========== ####

# CREATE PNG OUTPUT FOR RMD

op <- par()
par(op)
png("out_figure2_posteriors.png", width = 1350, height = 750)
par(mfrow = c(2,4), mar=c(2.5,5,5,0.5), family="Helvetica")

# Hispanic
# callback
  bayes.graph(depvar = dat$ncb_wh[dat$TA!=2], 
              treat  = (dat$TA1)[dat$TA!=2], 
              weight = dat$ipw10[dat$TA!=2], 
              block  = dat$block[dat$TA!=2],
              trt_text = "Monitoring",
              ylab = "Discrimination against Hispanics (vs. Whites)",
              print_title = TRUE)
  
  bayes.graph(depvar = dat$ncb_wh[dat$TA!=1],
              treat  = (dat$TA2)[dat$TA!=1], 
              weight = dat$ipw20[dat$TA!=1], 
              block  = dat$block[dat$TA!=1], 
              print_title = TRUE)

    # offer
  bayes.graph(depvar = dat$noff_wh[dat$TA!=2],
              treat  = (dat$TA==1)[dat$TA!=2], 
              weight = dat$ipw[dat$TA!=2], 
              block  = dat$block[dat$TA!=2], 
              main = "Offers", 
              trt_text = "Monitoring",
              print_title = TRUE)
  
  bayes.graph(depvar = dat$noff_wh[dat$TA!=1],
              treat  = (dat$TA==2)[dat$TA!=1], 
              weight = dat$ipw[dat$TA!=1],
              block  = dat$block[dat$TA!=1], 
              main = "Offers", 
              print_title = TRUE)

  # Black
  # callback
  bayes.graph(depvar = dat$ncb_wb[dat$TA!=2], 
              treat  = (dat$TA==1)[dat$TA!=2],
              weight = dat$ipw[dat$TA!=2], 
              block  = dat$block[dat$TA!=2], 
              trt_text = "Monitoring", 
              xloc = -0.15, 
              textadj = 0, 
              ylab = "Discrimination against Blacks (vs. Whites)")
  
  bayes.graph(depvar = dat$ncb_wb[dat$TA!=1], 
              treat  = (dat$TA==2)[dat$TA!=1], 
              weight = dat$ipw[dat$TA!=1],
              block = dat$block[dat$TA!=1],
              xloc = -0.15,
              textadj = 0)
  
  # offer
  bayes.graph(depvar = dat$noff_wb[dat$TA!=2], 
              treat  = (dat$TA==1)[dat$TA!=2], 
              weight = dat$ipw[dat$TA!=2],
              block  = dat$block[dat$TA!=2], 
              main = "Offers", 
              trt_text = "Monitoring",
              xloc = -0.15, 
              textadj = 0)
  
  bayes.graph(depvar = dat$noff_wb[dat$TA!=1], 
              treat  = (dat$TA==2)[dat$TA!=1],
              weight = dat$ipw[dat$TA!=1],
              block  = dat$block[dat$TA!=1], 
              main = "Offers",
              xloc = -0.15,
              textadj = 0)
  
dev.off()

```

```{r figure2pdf, echo=T, eval=T, warning=F}
##===========================================
# CREATE PDF OUTPUT FOR MANUSCRIPT OUTPUT

pdf("out_figure2_posteriors.pdf", width = 13.5, height = 7.5)
par(mfrow = c(2,4), mar=c(2.5,5,5,0.5), family="Helvetica") 
#TA: Treatment assignment -- {Control = 0, Monitoring = 1, Punitive = 2}

# Hispanic
# callback
bayes.graph(dat$ncb_wh[dat$TA!=2], (dat$TA==1)[dat$TA!=2], dat$ipw[dat$TA!=2], dat$block[dat$TA!=2], trt_text = "Monitoring", ylab = "Discrimination against Hispanics (vs. whites)", print_title = TRUE)
bayes.graph(dat$ncb_wh[dat$TA!=1], (dat$TA==2)[dat$TA!=1], dat$ipw[dat$TA!=1], dat$block[dat$TA!=1], print_title = TRUE)


# offer
bayes.graph(dat$noff_wh[dat$TA!=2], (dat$TA==1)[dat$TA!=2], dat$ipw[dat$TA!=2], dat$block[dat$TA!=2], main = "Offers", trt_text = "Monitoring", print_title = TRUE)
bayes.graph(dat$noff_wh[dat$TA!=1], (dat$TA==2)[dat$TA!=1], dat$ipw[dat$TA!=1], dat$block[dat$TA!=1], main = "Offers", print_title = TRUE)

# Black
# callback
bayes.graph(dat$ncb_wb[dat$TA!=2], (dat$TA==1)[dat$TA!=2], dat$ipw[dat$TA!=2], dat$block[dat$TA!=2], trt_text = "Monitoring", xloc = -0.15, textadj = 0, ylab = "Discrimination against Blacks (vs. whites)")
bayes.graph(dat$ncb_wb[dat$TA!=1], (dat$TA==2)[dat$TA!=1], dat$ipw[dat$TA!=1], dat$block[dat$TA!=1], xloc = -0.15, textadj = 0)

# offer
bayes.graph(dat$noff_wb[dat$TA!=2], (dat$TA==1)[dat$TA!=2], dat$ipw[dat$TA!=2], dat$block[dat$TA!=2], main = "Offers", trt_text = "Monitoring", xloc = -0.15, textadj = 0)
bayes.graph(dat$noff_wb[dat$TA!=1], (dat$TA==2)[dat$TA!=1], dat$ipw[dat$TA!=1], dat$block[dat$TA!=1], main = "Offers", xloc = -0.15, textadj = 0)

dev.off()
```

![**Figure 2: Posterior Densities of Treatment Effects on Discrimination against Hispanics (top) and African Americans (bottom) Relative to Whites**](out_figure2_posteriors.png)

## Randomization Check (reported in main text, footnote 14)

```{r randcheck, eval=T, echo=T, warning=F}
set.seed(1234567)
niter = 100

fmla <- " frame + partnered + rent + m.rent + numbr + sqft + m.sqft + 
          regime1 + regime2 + regime3 + nnumattr_bh + nnumattr_wh + 
          nnumattr_wb + nnumskep_bh + nnumskep_wh + nnumskep_wb + npctskep_bh + 
          npctskep_wh + npctskep_wb + nnumpos_bh + nnumpos_wh + nnumpos_wb + 
          nnumneu_bh + nnumneu_wh + nnumneu_wb + nnumneg_bh + nnumneg_wh + 
          nnumneg_wb + npctpos_bh + npctpos_wh + npctpos_wb + npctneu_bh + 
          npctneu_wh + npctneu_wb + npctneg_bh + npctneg_wh + npctneg_wb + 
          nanyskep_bh + nanyskep_wh + nanyskep_wb + nanyneg_bh + nanyneg_wh + 
          nanyneg_wb + team_gender + broker + callorder.wb + callorder.wh + 
          callorder.bh + incrank.wb.gt + incrank.wh.gt + incrank.bh.gt + 
          incrank.wb.eq + incrank.wh.eq + incrank.bh.eq + incrank.wb.lt + 
          incrank.wh.lt + incrank.bh.lt + boro.brx + boro.brk + boro.mnh + 
          boro.que + boro.stn + inc.w.hi + inc.b.hi + inc.h.hi + ll.female + 
          m.ll.female + primary_api + primary_blk + primary_hsp + primary_wht + 
          primary_age_18to34 + primary_age_35to44 + primary_age_45to64 + 
          primary_age_65over + primary_age_unknown + tid.A01 + tid.A10 + 
          tid.A11 + tid.A13 + tid.A02 + tid.A21 + tid.A22 + tid.A03 + 
          tid.A04 + tid.A05 + tid.A06 + tid.A07 + tid.A08 + tid.A09 + 
          tid.B01 + tid.B11 + tid.B12 + tid.B14 + tid.B16 + tid.B02 + 
          tid.B20 + tid.B23 + tid.B24 + tid.B25 + tid.B27 + tid.B03 + 
          tid.B04 + tid.B06 + tid.B07 + tid.B08 + tid.B09 + tid.C01 + 
          tid.C10 + tid.C12 + tid.C13 + tid.C14 + tid.C15 + tid.C02 + 
          tid.C27 + tid.C29 + tid.C03 + tid.C31 + tid.C33 + tid.C04 + 
          tid.C05 + tid.C06 + tid.C07 + tid.C08 + tid.C09 + as.factor(block)"

# trace=FALSE to suppress output about convergence
mnl_fit <-  multinom(formula = paste("TA ~ ", fmla), data = dat, weight = ipw, trace = FALSE) 
kparams = length(mnl_fit$coefnames)
mnl_loglik = -(mnl_fit$AIC - 2*kparams)/2   # log likelihood from actual model

# randomization inference
ri_mat = cbind(1:nrow(dat), dat$block, dat$TA)
blocks = names(table(dat$block))

# recalculate loglik stat for each shuffled vector of assignments
mnl_loglik_ri = rep(NA, niter)
fmla_ri = as.formula(paste0("z_ri ~ ", fmla))
for(j in 1:niter){
  shuffle_mat = list()
  for(i in 1:length(blocks)){
    block_z = ri_mat[ri_mat[,2] == blocks[i],3]
    shuffle_z = sample(block_z, length(block_z), replace=FALSE)
    shuffle_mat[[i]] = cbind(ri_mat[ri_mat[,2] == blocks[i],1:2], shuffle_z)
  }
  shuffle_mat = do.call(rbind, shuffle_mat)
  shuffle_mat = shuffle_mat[order(shuffle_mat[,1]),]
  dat$z_ri = shuffle_mat[,3]
  mnl_fit_ri = multinom(formula=fmla_ri, data=dat, weight=ipw, trace=FALSE)
  kparams = length(mnl_fit_ri$coefnames)
  mnl_loglik_ri[j] = -(mnl_fit_ri$AIC - 2*kparams)/2
}

# calculate p-value
mean(abs(mnl_loglik_ri) >= abs(mnl_loglik))
```


```{r, eval = run_appendix,  child = "Replicate_Appendix.Rmd"}
```

